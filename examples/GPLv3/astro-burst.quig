-- astro-burst -- a time-attack space driving game for quig, intended as a showpiece of what quig can do
-- astro-burst is (C) 2020-2022 B.M.Deeal. astro-burst is distributed under the GPLv3.

-- This file expects word-wrapping and a tab width of 4.

--[[
	This program is free software: you can redistribute it and/or modify it under the terms of version 3 of the GNU General Public License as published by the Free Software Foundation.

    This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
    See the GNU General Public License for more details.

    You should have received a copy of the GNU General Public License along with this program.
    If not, see <https://www.gnu.org/licenses/>.
--]]


--[[
	-about-
	astro-burst is a cosmic race against the clock!
	Stay between the gates and don't run out of time!
		
	-control-
	The controls are:
		[d-pad  start  a b]
	* A-button -- accelerate
	* B-button -- brake
	* Left/Right -- move
	* Start -- pause
	
	-how to play-
	Steer the spaceship through the gates with the d-pad. As you drive, you will encounter several gates with icons above them. These gates affect your ship in different ways:
	* Checkpoint -- Every checkpoint gate you pass through gives you a little bit more time, keeping you just that much further from being disqualified.
	* Ice -- Your ship will move a bit faster, but your controls are also far more sensitive. Exciting, but also dangerous. It's quite hard to recover when on ice, because your turning is very, very sensitive.
	* Slow -- Your ship will slow down quite a bit. You can't avoid it, so it can even help you take particularly hard corners... but in some cases, you might find yourself turning too hard as you pass through it and be sent flying off!
	* Magnet -- Your ship will be attracted away from the center. Stay near the center line to avoid or reduce the effect, and correct your course as needed.
	* Goal -- Passing through a goal gate ends the course and displays your score and time. Make some records and then smash through them!
	
	-scoring-
	Scoring boils down to how well you can follow the dotted line in the middle.
	In astro-burst, you don't lose any forward speed while turning, so the score system is designed to track how clean a line you can keep.
	This doesn't mean you can really slow down though -- you're slowly, but constantly losing points! Keep passing between the very center of the barriers to increase your score, and don't go out-of-bounds, or you'll lose a lot of points very quickly!
	A run that gets the best time mightn't be the one that gets the best score and vice-versa, but you still need to be quite quick to get either.
	
	---
	
	INFO:
	This game heavily influenced the design of quig and what I wanted to be able to do with it. In particular, it's the reason sprites can scale smoothly, which ties directly into why sprites are center-aligned.
	The code is aggressively heavily commented. Part of this is just personal preference, where I'll generally read the English text to see what I actually intended to do with a piece of code vs guessing from reading the code itself, but a lot was to explain my thought process to the reader.
	I may loosen the licensing restrictions on astro-burst at some point (not to CC0, of course), since it IS an example, but it's also a showpiece for what quig can do and it's not exactly a great place to take code from. I wasn't quite entirely new to Lua when I started it, but I wasn't familiar with any real best practices with the language when I started, and a lot of the design reflects on that. A lot of newer code follows existing design patterns just to not make things confusing.
	
	---
	
	TODO:
	* trophies -- if you've completed all stages on a given speed class or slower, you should be given a trophy for it, need to do art+code for that
	* half-side hazards -- should be really easy, just check if you're on one side of the middle line or not; could do fun stuff like half-side slow or half-side time, could make the player have to dodge around a bit, fun stuff
	* split-road object -- should probably be easy, we just mark an area in the middle where we treat things as out of bounds
	* decorative objects -- stages look a bit plain, might throw in some terrain types that don't actually affect the ship, they're just drawn differently [in progress!]
	* replays -- should probably try the naive method first of just adding to the table every frame, but at the same time, that just sounds expensive in terms of memory, could do a thing where it stores button up/downs for each frame and how long between them, astro-burst only has 4 relevant buttons too
	* how to play screen -- might just have it be a course with text on the screen explaining the controls while you drive through the various terrain types
	* more levels [in progress!]
	* major code cleanups -- in particular, a lot of things are done in a rather ad-hoc fashion
	* the code commenting in some spots is bad -- we explain everything because this is an example, but some stuff is underexplained while some stuff is way overexplained
	* score/time saving (quig now has some file handling support but it needs major testing and is in flux)
	* music/sound -- quig's stance on audio is deeply in flux and I need to figure out what I'm doing there
	* verticality? might give the courses some Z-axis movement, and it'd be neat to affect speed based on the vertical angle, but I don't know, I'd need to do some testing for whether it looks/feels good and I might need to do a decent bit of work that might end up getting scrapped
--]]


stages=7 --how many stages are there, change this before adding a new one

--convert a time in frames to mm'ss"cc format, where m is minutes, s is seconds, and c is centiseconds
function timeToString(n)
	local m=math.floor((n/60)/60)
	local s=math.floor((n/60)%60)
	local cs=math.floor(((n/60)*100)%100)
	return string.format("%02d'%02d\"%02d", m, s, cs)
end

--limit a value from 0-255, rounded down
function clampcolor(c)
	return math.floor(math.max(0,math.min(255,c)))
end

--draw a background gradient
function cls_grad(r,g,b,sp,n)
	if sp==nil then sp=true end --do we do special actions based on the speed class?
	if not n then n=4 end --how wide should the bars be? 
	local maxval=math.ceil(view_height/n)
	local special=1
	local special2=1
	--cycle the colors based on each speed class
	if sp then
		if speed_class==7 then
			special=1+math.sin(t/120)
			special2=1+math.sin(t/80)
		elseif speed_class==6 then
			special=1+math.sin(t/20)/8
		end
	end
	--draw rectangles repeatedly for the gradient
	for ii=0,maxval do
		rect(
			0,
			n*ii,
			view_width,
			n,
			clampcolor(r*1.5*ii*special/maxval),
			clampcolor(g*1.5*ii/maxval),
			clampcolor(b*1.5*ii*special2/maxval)
		)
	end
end

--how fast to go/difficulty setting
--there were originally just 5, but at this point, maniac is actually kind of easy for me since I've been working on this for so long now and even absurd isn't as off-the-wall as I wanted
speed_class=3; --3 is the normal class

--make a new table for holding speed class related stuff
--TODO: this gets called other places, when they could and should just use the sc table, GO REPLACE ALL CALLS OF makeSpeedTable(), add them to sc[] instead
--didn't think things through at the time, paying for it now, it's a real mess
function makeSpeedTable()
	return {
		{name="easy"},
		{name="basic"},
		{name="normal"},
		{name="turbo"},
		{name="maniac"},
		{name="absurd"}, --this was once called unfair, but I decided to make it more fun to play; TODO: make unlockable after you've cleared all 8 courses on any difficulty?
		{name="chaos"} --this one is kind of unfair lol
	}
end
sc=makeSpeedTable()

--acceleration speeds
sc[1].accel=0.0075 --easy
sc[2].accel=0.009 --basic
sc[3].accel=0.010 --normal
sc[4].accel=0.011 --turbo
sc[5].accel=0.0135 --maniac
sc[6].accel=0.0250 --absurd
sc[7].accel=0.0400 --chaos

--handle in-level split timing
splits={}

--initialize the time splits table
--the table named splits is actually just management
--the actual table holding split times per-stage is part of sc
--it's laid out like:
--   sc[speed_class].splits[cur_stage].current[split_number]
-- replace 'current' with 'best' for the best time splits
splits.setup=function()
	--cycle through the speed classes until we're out of them
	ii=1
	while sc[ii] ~= nil do
		--add a new split time table
		sc[ii].splits={}
		--add tables for each stage
		for jj=1,stages do
			sc[ii].splits[jj]={
				current={},
				best={}
			}
		end
		ii=ii+1
	end
	splits.init()
end

--set up the split counter system
splits.init=function()
	splits.counter=0
	splits.index=1
	splits.counter_max=300 --how many objects to pass
	splits.showtime=0
	splits.showtime_max=60*3
	splits.showvalue=0
end

--draw the current split every once in a while
splits.draw=function()
	--ticking down timer for actually displaying the split
	if splits.showtime>0 then
		--handle +/- sign
		--TODO: should there be a - sign before an unset split?
		local ch="+"
		local value=math.abs(splits.showvalue)
		if splits.showvalue<0 then
			ch="-"
		end
		--flash the text, count down the timer
		if splits.showtime%20<15 then
			text(ch..timeToString(value),0,8,1,1)
		end
		splits.showtime=splits.showtime-1
	end
end

--tick the internal counter upwards every time we pass an object
--don't update this each frame, only bother when we pass an object
splits.update=function()
	if splits.counter>splits.counter_max then
		splits.counter=0
		splits.add()
		splits.showtime=splits.showtime_max
	else
		splits.counter=splits.counter+1
	end
end

splits.setup()

--add a split
--wow, this got ugly really fast
splits.add=function()
	--clean up some ugliness, although I remember reading on the lua wiki that apparently doing this is faster since accessing globals is slower than accessing locals
	local cur_stage=gmode.stage_select.selection
	local n=splits.index
	local last_best=sc[speed_class].splits[cur_stage].best[n]
	--check if there's a split at all, make it so that the player was always faster by the current time on the clock otherwise
	if last_best == nil then
		last_best=player.runtime*2
	end
	--set the current split
	sc[speed_class].splits[cur_stage].current[n]=player.runtime
	--if we set a new best split/one doesn't exist yet, add a new best one
	if sc[speed_class].splits[cur_stage].best[n] == nil or player.runtime < sc[speed_class].splits[cur_stage].best[n] then
		sc[speed_class].splits[cur_stage].best[n] = player.runtime
	end
	--get the difference
	splits.showvalue=player.runtime-last_best
	splits.index=splits.index+1
end


--background colors for each speed class
--they used to be drawn exactly, but now there's the gradient modifying them, so this is more of a "middle of the screen" color than anything specific since the background gradient system brightens the colors passed to them
--also, some of them get altered programmatically
sc[1].bg={r=2,  g=2,  b=36}
sc[2].bg={r=4,  g=4,  b=30}
sc[3].bg={r=6,  g=6,  b=26}
sc[4].bg={r=7,  g=6,  b=22}
sc[5].bg={r=6,  g=4,  b=18}
sc[6].bg={r=50,  g=10,  b=20}
sc[7].bg={r=30,  g=50,  b=40}

--holds how much time you get at the start
sc[1].time=40
sc[2].time=30
sc[3].time=20
sc[4].time=18
sc[5].time=17
sc[6].time=15
sc[7].time=14.5

--holds how much time passing a checkpoint gate gives you
time_bonuses=makeSpeedTable()
time_bonuses[1].time=28
time_bonuses[2].time=25
time_bonuses[3].time=22
time_bonuses[4].time=21
time_bonuses[5].time=20
time_bonuses[6].time=17
time_bonuses[7].time=15

--save best times/scores
best_times=makeSpeedTable()
best_scores=makeSpeedTable()

--far background
--TODO: should probably set a defined random seed to make the stars stay the same for each individual stage
stars={}
stars.init=function()
	stars.max=10
	stars.offset_x=0 --how far to scroll them
	stars.offset_y=0
	--throw some stars around
	for ii=1,stars.max do
		stars[ii]={}
		stars[ii].x=math.random(view_width)
		stars[ii].y=math.random(view_height)
		stars[ii].t=math.random(5,7)
		stars[ii].scale=math.random(6,10)/10
	end
end

--slap some stars on screen
--TODO: make the stars infinitely scrollable
stars.draw=function()
	for ii=1,stars.max do
		spr(stars[ii].x+stars.offset_x, stars[ii].y+stars.offset_y, stars[ii].scale, stars[ii].t, 0)
	end
end

--camera position and etc
camera={}
camera.init=function()
	--position
	camera.x=0
	camera.y=-400
	--center
	camera.cx=view_width/2
	camera.cy=view_height/2
	--this isn't exactly FOV proper, so don't mess with it
	camera.fov=16 
	--anything too close
	camera.near=0.5
end

--stage handling
levels={}
levels.create={}
levels.init=function()
	levels.length=0 --how many objects in the level
	levels.c_distance=0 --distance from next object group
	levels.c_width=4000 --width of track
	levels.c_offset=0 --horizontal offset of track
	levels.c_flag=0 --road type for track
	levels.index=1 --which track segment are we on
	--used to interpolate level segments
	levels.offset_diff=0 
	levels.width_diff=0
end

--objects are generated with linearly interpolated widths and offsets
--TODO: use the side parameter (-1 for left, 1 for right, 0 for center)
levels.add=function(w,o,d,f,s)
	if not f then f=0 end
	if not s then s=0 end
	local n=levels.length+1
	levels.length=n
	levels[n]={width=w, offset=o, distance=d, flag=f, side=s} 
end

--get track data to generate objects with
levels.get=function()
	local flag=0
	--every time we move ahead, we get the next item
	levels.c_distance=levels.c_distance-1
	if (levels.c_distance<0) then
		levels.index=levels.index+1
		--this shouldn't happen if there's a goal area, but we force an out of bounds condition if we go past the end of the level
		if (levels.index>levels.length) then
			return -30000,0
		end
		--get the terrain type, how long the segment is, and then calculate the interpolation for the width and offset
		levels.c_flag=levels[levels.index].flag
		levels.c_distance=levels[levels.index].distance
		levels.width_diff=(levels[levels.index].width-levels.c_width)/levels.c_distance
		levels.offset_diff=(levels[levels.index].offset-levels.c_offset)/levels.c_distance
	else
		--interpolate each road element to the given width/offset
		levels.c_width=levels.c_width+levels.width_diff
		levels.c_offset=levels.c_offset+levels.offset_diff
	end
	return levels.c_width,levels.c_offset,levels.c_flag
end

--beginning preamble to every level
levels.start=function()
	levels.init()
	levels.add(4000,0,100) --this actually gets skipped
	levels.add(4000,0,20)
end

--goal area for every level
levels.finish=function()
	levels.add(5000,0,30)
	levels.add(10,0,20,2) --goal!
end

--entirely for debug purposes
levels.create[0]=function()
	levels.start()
	levels.finish()
end

--levels
--each level actually just resets the levels table entirely and repopulates it programmatically
--the details for the 4th parameter for levels.add can be found in objects.add (importantly, checkpoints are 1)
--TODO: constants for road object types to make this more readable
levels.create[1]=function()
	levels.start()
	levels.add(1400,2900,20)
	levels.add(1300,5000,20,6)
	levels.add(3000,0,40)
	levels.add(4000,10000,30)
	levels.add(2000,0,30)
	levels.add(2000,0,25,1)
	levels.add(4000,-10000,20,6)
	levels.add(3000,-12000,10,6)
	levels.add(4000,-20000,30,6)
	levels.add(2000,0,100)
	levels.add(4000,-6000,25,1)
	levels.add(4000,-7000,10)
	levels.add(4000,-19000,12)
	levels.add(4000,7000,40)
	levels.add(3000,7000,20)
	levels.add(2000,7000,30)
	levels.add(4000,0,50)
	levels.add(1000,4000,20)
	levels.add(1200,4000,12,1)
	levels.add(2000,10000,20)
	levels.add(3000,16000,20)
	levels.add(3500,20000,10)
	levels.add(2000,0,40,6)
	levels.add(2000,0,22,1)
	levels.add(3000,10000,30)
	levels.add(3000,20000,24)
	levels.add(3000,30000,15)
	levels.add(3000,40000,12)
	levels.add(3000,40000,50)
	levels.add(4000,0,50)
	levels.add(2000,0,20,6)
	levels.add(1000,500,10)
	levels.add(1200,0,30,1)
	levels.add(1400,15000,60)
	levels.add(1600,30000,40)
	levels.add(2000,30000,30,6)
	levels.add(3000,15000,20)
	levels.add(3000,0,60)
	levels.finish()
end

levels.create[2] = function()
	levels.start()
	levels.add(4000,0,50)
	levels.add(3000,2000,30,3)
	levels.add(1000,-1600,30,3)
	levels.add(2500,-1700,30,1)
	levels.add(1000,2000,30,3)
	levels.add(3000,0,40)
	levels.add(1000,1500,10)
	levels.add(5000,0,10)
	levels.add(1000,-1500,10)
	levels.add(5000,0,10)
	levels.add(1000,1500,10)
	levels.add(5000,0,10)
	levels.add(2000,-10000,20)
	levels.add(2500,-10000,22,1)
	levels.add(1500,-10000,20)
	levels.add(2000,-10000,10)
	levels.add(2000,-15000,10)
	levels.add(3000,-25000,13,6)
	levels.add(1500,-24000,40)
	levels.add(2000,-24000,30)
	levels.add(3000,-10000,20,6)
	levels.add(2500,-2000,30)
	levels.add(2000,0,22,1)
	levels.add(2000,0,30)
	levels.add(2000,3000,20)
	levels.add(900,0,20)
	levels.add(1000,0,10)
	levels.add(2000,-3500,20)
	levels.add(900,0,20)
	levels.add(2000,5000,25)
	levels.add(1000,0,20)
	levels.add(2000,-5500,25)
	levels.add(1000,0,20)
	levels.add(2000,0,42,1)
	levels.add(3000,0,10)
	levels.add(3500,5000,20)
	levels.add(4000,10000,18)
	levels.add(3900,20000,16)
	levels.add(4000,30000,14,6)
	levels.add(2000,30000,14)
	levels.add(800,30000,40)
	levels.add(2500,30000,30)
	levels.add(3000,20000,20,6)
	levels.add(3100,10000,10,6)
	levels.add(2000,10000,10,6)
	levels.add(3500,10000,10,6)
	levels.add(2000,20000,20,6)
	levels.add(1900,0,30)
	levels.add(2000,0,25,1)
	levels.add(2000,0,30)
	levels.add(1200,0,20)
	levels.add(1100,2800,25)
	levels.add(1000,3000,20)
	levels.add(1200,0,20)
	levels.add(1000,0,20)
	levels.add(3000,0,10)
	levels.add(1000,3000,20)
	levels.add(3000,0,10)
	levels.add(800,-3000,20)
	levels.add(3000,0,10)
	levels.add(2000,-2000,40)
	levels.add(2800,0,10)
	levels.add(3000,10000,10)
	levels.add(800,6000,30)
	levels.add(800,6000,20,1)
	levels.add(800,6000,30)
	levels.add(3000,0,30,3)
	levels.finish()
end

levels.create[3] = function()
	levels.start()
	levels.add(4000,1000,30)
	levels.add(4000,5000,30)
	levels.add(4000,6000,35,1)
	levels.add(3500,13000,50)
	levels.add(2000,0,40,3)
	levels.add(1300,6000,40,3)
	levels.add(2000,16000,40,3)
	levels.add(1000,32000,40,3)
	levels.add(2100,36000,20,3)
	levels.add(2000,31000,20)
	levels.add(4000,31000,30,1)
	levels.add(4000,20000,10)
	levels.add(5000,0,30)
	levels.add(1000,-10000,20)
	levels.add(3000,-10000,20)
	levels.add(1000,0,40)
	levels.add(5000,0,30)
	levels.add(1000,-10000,20)
	levels.add(3000,-15000,20)
	levels.add(1000,0,40)
	levels.add(2000,100,35,1)
	levels.add(5000,0,30)
	levels.add(1000,-9000,20)
	levels.add(3000,-10000,20)
	levels.add(1200,0,40)
	levels.add(4000,1000,8)
	levels.add(2000,-4000,60,3)
	levels.add(2000,29000,60,3)
	levels.add(2000,29000,30)
	levels.add(2000,29000,35,1)
	levels.add(4000,10000,30)
	levels.add(4000,0,20)
	levels.add(3000,-9500,20)
	levels.add(2000,20000,60)
	levels.add(1200,30000,20)
	levels.add(4000,35000,15,3)
	levels.add(1600,30000,50)
	levels.add(2000,10000,50)
	levels.add(1200,400,40,1)
	levels.add(5200,1400,30)
	levels.add(1200,-2700,30)
	levels.add(5200,400,30)
	levels.add(1200,1700,30)
	levels.add(5200,400,30)
	levels.add(900,3000,40,3)
	levels.add(1300,-2000,50)
	levels.add(2200,1500,40)
	levels.add(1100,1200,30)
	levels.finish()
end

levels.create[4] = function()
	levels.start()
	levels.add(2000,0,30)
	levels.add(2000,4000,30,4)
	levels.add(2000,0,30)
	levels.add(4000,0,20,4)
	levels.add(2000,180,20,4)
	levels.add(3000,0,20,4)
	levels.add(2200,-6000,20)
	levels.add(3000,-5000,5,5)
	levels.add(3000,10800,15)
	levels.add(2400,22040,20)
	levels.add(2700,20040,10)
	levels.add(3000,12000,10)
	levels.add(2300,-1000,25)
	levels.add(2000,-1000,40,1)
	levels.add(4000,0,20)
	levels.add(3000,2000,10)
	levels.add(5000,20000,20)
	levels.add(1000,20000,20)
	levels.add(3000,10000,20)
	levels.add(1000,9000,30,3)
	levels.add(2000,5000,20,3)
	levels.add(1000,0,15)
	levels.add(1000,0,15,1)
	levels.add(1000,1000,60)
	levels.add(1000,15000,30)
	levels.add(1000,15000,30)
	levels.add(2000,6000,20)
	levels.add(1000,6000,20)
	levels.add(2000,-8000,30)
	levels.add(1500,-4000,15,1)
	levels.add(1000,0,20)
	levels.add(4000,2000,20)
	levels.add(1000,0,20)
	levels.add(3000,-2000,20)
	levels.add(1000,1200,20)
	levels.add(1500,1200,20,1)
	levels.add(2000,1200,20)
	levels.add(1800,-2000,20,4)
	levels.add(1800,-8000,20,4)
	levels.add(1800,-7200,0)
	levels.add(1800,-13000,20,3)
	levels.add(1800,-8000,20)
	levels.add(2600,-1000,20,4)
	levels.finish()
end

levels.create[5]=function()
	levels.start()
	levels.add(1000,0,50)
	levels.add(1000,-3000,40)
	levels.add(900,1000,25,1)
	levels.add(900,100,40)
	levels.add(1000,10000,40)
	levels.add(1000,10000,40)
	levels.add(4000,-4000,20)
	levels.add(4000,-4000,20)
	levels.add(2000,-4000,20,1)
	levels.add(1000,13000,30,3)
	levels.add(3000,13000,10)
	levels.add(3300,4000,30)
	levels.add(3300,4000,5)
	levels.add(1000,10000,30,3)
	levels.add(1000,10000,5)
	levels.add(2200,18000,30)
	levels.add(2200,18000,5)
	levels.add(1500,5600,25)
	levels.add(1500,5600,10,1)
	levels.add(3000,0,20)
	levels.add(3000,15000,30,3)
	levels.add(2000,0,30,3)
	levels.add(800,0,30,1)
	levels.add(2000,0,30,3)
	levels.add(3000,-15000,30,3)
	levels.add(3000,0,30,3)
	levels.add(1000,0,10)
	levels.add(1700,0,10)
	levels.add(1400,0,10,4)
	levels.add(1700,2000,10,4)
	levels.add(1400,0,10)
	levels.add(1700,-2000,10,4)
	levels.add(1000,0,10)
	levels.add(1000,0,10)
	levels.add(1100,16000,80)
	levels.add(1100,16000,25,1)
	levels.add(1100,0,80)
	levels.add(4000,0,20)
	levels.add(800,0,5)
	levels.add(4000,0,20)
	levels.add(800,2700,7)
	levels.add(4000,2700,20)
	levels.add(800,0,9)
	levels.add(6000,0,20)
	levels.add(800,-2700,7)
	levels.add(4000,-2000,20)
	levels.add(800,0,9)
	levels.add(1000,600,40)
	levels.add(1800,0,30,4)
	levels.finish()
end

levels.create[6]=function()
	levels.start()
	levels.add(2000,-6000,40)
	levels.add(2000,0,50,3)
	levels.add(2000,5000,20,3)
	levels.add(3000,0,30,1)
	levels.add(4000,0,20,6)
	levels.add(4000,16000,20,6)
	levels.add(5000,16000,8,6)
	levels.add(3000,0,50,6)
	levels.add(5000,0,8,6)
	levels.add(4000,-16000,20,6)
	levels.add(5000,-16000,8,6)
	levels.add(4000,0,20,6)
	levels.add(1000,0,20,1)
	levels.add(1100,0,20)
	levels.add(7000,0,20)
	levels.add(1400,2000,20)
	levels.add(6000,-4000,20)
	levels.add(1700,-6000,20)
	levels.add(1700,-6000,10)
	levels.add(5000,8000,20)
	levels.add(2000,10000,20)
	levels.add(2000,10000,10)
	levels.add(4000,-12000,20)
	levels.add(4000,-12000,10)
	levels.add(2000,0,20)
	levels.add(2000,0,25,1)
	levels.add(2000,0,20)
	levels.add(1000,-2100,50,4)
	levels.add(1000,1000,20,3)
	levels.add(2000,-5000,50,3)
	levels.add(3000,20000,40,4)
	levels.add(3000,20000,20,4)
	levels.add(4000,20000,10)
	levels.add(1000,20000,35,1)
	levels.add(4000,20000,10)
	levels.add(1000,20000,40,4)
	levels.add(3000,20000,40,4)
	levels.add(2000,10000,40,3)
	levels.add(1000,10000,40,3)
	levels.add(6000,10000,10,3)
	levels.add(1000,-10000,40,3)
	levels.add(1000,-10000,20,3)
	levels.add(3000,10000,40,3)
	levels.finish()
end

levels.create[7]=function()
	levels.start()
	levels.add(800,-1000,30,6)
	levels.add(4000,0,15,6)
	levels.add(1100,2000,15,6)
	levels.add(4000,0,15,6)
	levels.add(1000,0,25,1)
	levels.add(3000,1000,20)
	levels.add(1320,-2000,10)
	levels.add(4000,0,10)
	levels.add(1000,-1000,20,6)
	levels.add(4000,2000,20,6)
	levels.add(1000,-1000,20,6)
	levels.add(800,-1500,10)
	levels.add(2000,-3000,10,3)
	levels.add(1000,-5000,10,3)
	levels.add(1000,-7000,10,3)
	levels.add(1000,0,25)
	levels.add(1000,0,25,1)
	levels.add(2000,0,25)
	levels.add(1000,0,25,3)
	levels.add(2000,7000,25)
	levels.add(2000,15000,25)
	levels.add(1500,20000,25)
	levels.add(1500,20000,10)
	levels.add(2000,18000,7)
	levels.add(2000,16000,5)
	levels.add(2000,2000,20)
	levels.add(2000,0,10)
	levels.add(4000,0,25,1)
	levels.add(4000,-10000,25)
	levels.add(1000,-15000,25,4)
	levels.add(2000,-10000,25,3)
	levels.add(2000,0,20)
	levels.add(2000,-7000,25)
	levels.add(2000,-15000,25)
	levels.add(2500,-20000,25)
	levels.add(1500,-20000,30)
	levels.add(1500,0,30)
	levels.add(1500,0,5,1)
	levels.add(1500,-20000,30)
	levels.add(1500,-20000,5)
	levels.add(1500,0,30)
	levels.add(1600,1000,10,1)
	levels.add(500,0,30)
	levels.add(4500,3000,20)
	levels.add(1500,-1000,20)
	--TODO: make longer, probably needs a longish checkpoint here too
	levels.finish()
end

--TODO: more levels (I want 8 at the minimum)

--smoothly move to a point
--repeatedly doing it to a variable slides it continually somewhere
--I don't know the proper name for this, but it's dead useful
function target(n,tgt,time)
	return (n+tgt*time)/(time+1)
end

--smoothly move the camera
camera.target=function(tgt)
	camera.x=target(camera.x,tgt,4)
end

--get2D -- convert a 3D point to a 2D one
--returns 3 values -- x,y, and scale
camera.get2D = function(x,y,z)
	local rx,ry,rs
	local tz=z/camera.fov
	if (tz<camera.near) then
		return -32,-32,0.5
	end
	rx=(x-camera.x)/z+camera.cx
	ry=(y-camera.y)/z+camera.cy
	rs=1/tz
	return rx,ry,rs
end

--particle handling
--particles are tiny and don't get sorted and only show up every other frame
particles={}
particles.init=function()
	particles.max=64
	for ii=1,particles.max do
		particles[ii]={active=0,x=0,y=0,z=0,r=0,g=0,b=0}
	end
end

--half the particles get drawn each frame
--particles don't need to be sorted in this game, they're very ephemeral
particles.draw=function()
	local odd=0
	if flip > 0 then odd=1 end
	for ii=1+odd,particles.max,2 do
		local rx,ry,rs
		rx,ry,rs=camera.get2D(particles[ii].x, particles[ii].y, particles[ii].z)
		squ(rx,ry,rs, particles[ii].r, particles[ii].g,particles[ii].b)
	end
end

--update all of the particles
--probably should only update the visible half of the particles each frame, but alas
particles.update=function()
	for ii=1,particles.max do
		if particles[ii].active==1 then
			particles[ii].z=particles[ii].z-player.speed-0.3
			if particles[ii].z/camera.fov < camera.near then
				particles[ii].active=0
			end
		end
	end
end

--add a particle of a given color at a given point
particles.addDirect=function(x,y,z,r,g,b)
	for ii=1,particles.max do
		if particles[ii].active==0 then
			particles[ii].active=1
			particles[ii].x=x
			particles[ii].y=y
			particles[ii].z=z
			particles[ii].r=r
			particles[ii].g=g
			particles[ii].b=b
			return
		end
	end
end

--generate randomly colored particles in the distance, the color range is between lo and hi
particles.add=function(x,y,lo,hi)
	particles.addDirect(x+player.x,y,200, math.random(lo,hi),math.random(lo,hi),math.random(lo,hi))
end

--object handling
--or, at the very least, the road barriers
objects={}
objects.init=function()
	objects.odd=-1
	objects.max=36
	for ii=1,objects.max do
		objects[ii]={
			active=0, --is the object in the table being used
			tx=0,ty=0, --texture item
			x=0,y=0,z=0, --position
			width=0, --course width
			passed=false, --has the object been passed by the player yet (TODO: probably could sort where to draw the player object using this? haven't thought about it, but we could do two draw passes)
			odd=0 --do different things every other object (like the overhead signs, or the center-line dots)
		}
	end
end

--move objects forward to the player, the player gets to stay still
objects.update=function()
	--objects are always sorted by distance
	table.sort(objects,objects.cmp)
	--local inactive_count=0 --debug counter to check object usage
	for ii=1,objects.max do
		if objects[ii].active==1 then
			--move all active objects ahead
			objects[ii].z=objects[ii].z-player.speed
			--remove objects that are out of view
			if objects[ii].z/camera.fov < camera.near then
				objects[ii].active=0
			end
			--handle passing different road segments
			if objects[ii].z < player.z and objects[ii].passed==false then
				--deal with score
				player.score_gain_last=player.score_gain
				player.score_gain=math.max(0, 1000-math.abs(player.x-objects[ii].x)//3)
				if player.score_gain > 950 then player.score_gain=990 end
				player.score=player.score+player.score_gain
				--what surface are we on?
				player.status=objects[ii].flag
				--checkpoint
				if objects[ii].flag==1 then
					player.time=player.time + time_bonuses[speed_class].time
					clock_big=60
				end
				--fix a nasty corner case that made the player go out-of-bounds early (better to add slop than take away space)
				--a somewhat literal corner case, since we don't smoothly interpolate between two objects, so the player is still bound by the width of the current one until the next one, like they're hard corners
				--this makes it so that the player object can decide between the last object and the current one being passed
				if objects[ii-1] and not objects[ii-1].passed then
					player.offset2=objects[ii-1].x
					player.width2=objects[ii-1].width
				else
					player.offset2=objects[ii].x
					player.width2=objects[ii].width
				end
				player.offset=objects[ii].x
				player.width=objects[ii].width
				objects[ii].passed=true
			end
		--this was part of a debug counter for me to see how many objects were on screen
		--else
			--inactive_count=inactive_count+1
		end
	end
	--print(inactive_count)
end

--draw the side-barriers
--this feels like it should be slow, but there really isn't ever that much on screen
--still, it probably could be heavily, heavily optimized (in particular, we constantly re-divide for the scale despite a lot of things being at the same z distance, but I'm not touching that right now)
--it's also a bit really messy
--TODO: a call to player.draw should probably end up in here
objects.draw=function()
	--objects are expected to be pre-sorted
	--table.sort(objects,objects.cmp) 
	for ii=1,objects.max do
		if objects[ii].active==1 then
			local rx,ry,rs
			if objects[ii].z<=220 then
				--draw left side
				rx,ry,rs=camera.get2D(objects[ii].x-objects[ii].width,objects[ii].y,objects[ii].z)
				--shake on the highest speed class
				if speed_class>=6 and t%3==0 then
					rs=rs*(1+math.random()*0.35)
				end
				spr(rx,ry,rs*3,objects[ii].tx,objects[ii].ty)
				rx,ry,rs=camera.get2D(objects[ii].x-objects[ii].width,objects[ii].y+500*flip,objects[ii].z)
				squ(rx,ry,rs,177,62,83)
				--draw right side
				rx,ry,rs=camera.get2D(objects[ii].x+objects[ii].width, objects[ii].y, objects[ii].z)
				--shake on the highest speed class
				if speed_class>=6 and t%3==0 then
					rs=rs*(1+math.random()*0.35)
				end
				spr(rx,ry,rs*3,objects[ii].tx,objects[ii].ty)
				rx,ry,rs=camera.get2D(objects[ii].x+objects[ii].width, objects[ii].y+500*(-flip), objects[ii].z)
				squ(rx,ry,rs,56,183,100)
			end
			--draw middle
			if objects[ii].odd<0 then
				rx,ry,rs=camera.get2D(objects[ii].x, objects[ii].y+1000,objects[ii].z)
				squ(rx,ry,rs,159,128,73)
			end
			--draw decorative tunnel
			if objects[ii].flag == 6 and objects[ii].odd > 0  then
				rx,ry,rs=camera.get2D(objects[ii].x - objects[ii].width*2/3, objects[ii].y-2000, objects[ii].z)
				spr(rx,ry,rs*6,objects[ii].tx,objects[ii].ty)
				rx,ry,rs=camera.get2D(objects[ii].x + objects[ii].width*2/3, objects[ii].y-2000, objects[ii].z)
				spr(rx,ry,rs*6,objects[ii].tx,objects[ii].ty)
			--overhead signs, etc
			elseif objects[ii].flag ~=0 and objects[ii].odd>0 then
				rx,ry,rs=camera.get2D(objects[ii].x, objects[ii].y-3000, objects[ii].z)
				spr(rx,ry,rs*9,objects[ii].tx,objects[ii].ty)
			end
		end
	end
end

--add objects
--we basically check that if the object z is less than the player's, and the player hasn't passed another object, then slow the player down heavily if they're out-of-bounds
-- x is how far off the center we shift, width is how wide the road is
objects.add=function(offset, width, flag)
	if not flag then flag=0 end
	for ii=1,objects.max do
		if objects[ii].active==0 then
			objects[ii].active=1
			objects[ii].x=offset
			objects[ii].y=200
			objects[ii].z=280 --adjust this to adjust draw distance, but this also affects how long before the player reaches the road at all
			objects[ii].width=width
			objects[ii].passed=false
			objects[ii].tx=1
			objects[ii].ty=0
			objects[ii].odd=objects.odd
			objects.odd=-objects.odd
			objects[ii].flag=flag
			--object types:
			--TODO: add a split road type, there are already sprites in the sprite sheet
			--checkpoints
			if flag==1 then objects[ii].tx=3 end
			--goal
			if flag==2 then objects[ii].tx=2 end
			--ice (no x-friction, slow turning speed)
			if flag==3 then
				objects[ii].tx=1
				objects[ii].ty=1
			end
			--magnet (pull player toward sides)
			if flag==4 then
				objects[ii].tx=2
				objects[ii].ty=1
			end
			--slow (force player speed to drop, eg before very hard corners)
			if flag==5 then
				objects[ii].tx=3
				objects[ii].ty=1
			end
			--decoration 1
			--TODO: add another purely decorative road type
			if flag==6 then
				objects[ii].tx=6
				objects[ii].ty=1
			end
			return
		end
	end
end

--sort two objects by z value
objects.cmp=function(a,b)
	if a.z > b.z then return true end
	return false
end

--handle the player
player={}
player.init=function()
	player.status=0 --what surface are we driving on?
	player.oob=false --are we out of bounds?
	player.oobtimer=0 --how long to show the out of bounds text after returning in bounds
	player.time=sc[speed_class].time*60 --time remaining
	player.runtime=0 --play time
	player.score=0 --added a score system for a somewhat different challenge than just gotta-go-fast
	player.score_gain=0 --how much did you earn?
	player.score_gain_last=0 --used to calculate the score difference from object to object
	player.x=0 --horizontal position
	player.xd=0 --horizontal movement speed
	--a bit of the following is player physics stuff
	player.xmax_normal=200 --max horizontal speed under normal conditions
	player.xmax_ice=270 --max horizontal speed on ice
	player.xmax=player.xmax_normal --current max horizontal speed
	player.xmaxslow=160 --max horizontal speed when out of bounds
	player.xdspeed_normal=10 --normal turning speed
	player.xdspeed_ice=13 --turning speed on ice
	player.xdspeed=player.xdspeed_normal --current turning speed
	player.xdfriction_normal=6 --normal horizontal friction
	player.xdfriction_ice=2.5 --horizontal friction on ice
	player.xdfriction=player.xdfriction_normal --current horizontal friction
	player.z=8 --position in the world (this doesn't change, the world moves toward the player)
	player.speed=3 --movement speed (stages are done with a rolling start)
	--max speed
	--TODO: move to sc table
	--TODO: this is a mess and has remnants from a much earlier revision of the game
	player.maxspeed_normal=makeSpeedTable()
	player.maxspeed_normal[1]=2.8
	player.maxspeed_normal[2]=3.3
	player.maxspeed_normal[3]=4
	player.maxspeed_normal[4]=4.75
	player.maxspeed_normal[5]=5.5
	player.maxspeed_normal[6]=6.75
	player.maxspeed_normal[7]=8
	player.maxspeed=player.maxspeed_normal
	player.speedaccel=sc[speed_class].accel --how fast to accelerate
	player.speedfriction=0.03 --how fast to slow down
	player.speedslow=0.25
	--out-of-bounds conditions:
	--when the player passes a side-barrier (or rather, when a side-barrier passes the player), these get updated
	--we use two of them because of an issue where the player would get caught way too early when turning into an expanding road
	--TODO: do these need to be defined here in the player object?
	player.offset=0
	player.width=4000
	player.offset2=0
	player.width2=4000
	player.counter=0 --when this hits the required number, the next barrier is created
	player.countertop=10 --distance to the next barrier
end

--handle player movement
player.update=function()
	--reset normal constants
	player.xdspeed=player.xdspeed_normal
	player.xdfriction=player.xdfriction_normal
	player.xmax=player.xmax_normal
	player.maxspeed=player.maxspeed_normal[speed_class]
	--finish line!
	if player.status==2 then
		gmode.set(gmode.stage_clear)
		return
	end
	--ice
	if player.status==3 then
		player.xdspeed=player.xdspeed_ice
		player.xdfriction=player.xdfriction_ice
		player.xmax=player.xmax_ice
		player.maxspeed=player.maxspeed+0.32
	end
	--slow
	--TODO: different slow values based on speed class?
	--or maybe just a fixed ratio based on max speed
	--the highest two speed classes probably do need special handling, you don't get slowed down much at all
	if player.status==5 then
		if player.speed>1.5 then player.speed=player.speed-0.25 end
	end	
	--adjust turning speed based on forward speed a bit
	player.xdspeed=player.xdspeed*(2+player.speed/4)/3
	if player.speed < 2 then
		player.xdspeed=player.xdspeed*(1+player.speed)/3
	end
	--player speed control
	--accelerate
	--we auto-accelerate at the very start of the stage so if you aren't holding the gas at the beginning, your time isn't immediately ruined
	if key(key_a)>0 or player.runtime < 60 then 
		player.speed=player.speed+player.speedaccel
	else
		player.speed=player.speed-player.speedfriction
	end
	--braking
	--TODO: maybe adjust based on speedclass -- lower classes don't need such strong brakes
	if key(key_b)>0 then
		player.speed=player.speed-0.15
	end
	--limit horizontal speed
	if player.xd > player.xmax then player.xd=player.xmax end
	if player.xd < -player.xmax then player.xd=-player.xmax end
	--player movement
	if key(key_left)>0 then --go left
		player.xd=player.xd-player.xdspeed
	elseif key(key_right)>0 then --go right
		player.xd=player.xd+player.xdspeed
	--friction
	else
		if player.xd > player.xdfriction then
			player.xd=player.xd-player.xdfriction
		elseif player.xd < -player.xdfriction then
			player.xd=player.xd+player.xdfriction
		else
			player.xd=0
		end
	end
	--check for out of bounds
	local left_barrier, right_barrier, left_barrier2, right_barrier2
	player.oob=false
	--we give a bit of leniency here, checking both the current and upcoming barriers for out-of-bounds, and only saying that's it if both are true
	--this bit could probably be simplified
	left_barrier=player.offset-player.width-280
	right_barrier=player.offset+player.width+280
	left_barrier2=player.offset2-player.width2-280
	right_barrier2=player.offset2+player.width2+280
	if (player.x < left_barrier or player.x > right_barrier) and (player.x < left_barrier2 or player.x > right_barrier2) then
		player.oob=true
		--cap forward speed
		if player.speed >2 then player.speed=2 end
		if player.speed>1 then
			player.speed=player.speed-player.speedslow
		end
		--penalize player, reducing score and time
		--highest two speed classes take a slightly lower time penalty because they already have so little time
		if speed_class<6 then
			player.time=player.time-3
		elseif speed_class==6 then
			player.time=player.time-2.625
		elseif speed_class==7 then
			player.time=player.time-2.5
		end
		player.score=player.score-100
		player.score_gain=player.score_gain-100
		--limit horizontal speed
		if player.xd > player.xmaxslow then player.xd=player.xmaxslow end
		if player.xd < -player.xmaxslow then player.xd=-player.xmaxslow end
	end
	--magnet
	--this check is in an odd place because it needs to know oob status
	--TODO: magnets behave kind of odd, I should probably redesign this maybe
	if player.status==4 and player.speed > 0.6 and not player.oob then
		local magnet_pull=4.2
		if (player.x > player.offset+magnet_pull and player.xd<100) then
			player.xd=player.xd+magnet_pull
		elseif (player.x < player.offset-magnet_pull and player.xd>-100) then
			player.xd=player.xd-magnet_pull
		end
	end
	--player forward friction
	--kind of goofy since we're in space, but nothing makes sense given the setting in astro-burst, the space theme is just to look cool
	if player.speed < 0 then player.speed=0 end
	if player.speed > player.maxspeed then player.speed=player.maxspeed end
	player.counter=player.counter+player.speed --actually move ahead in the object list
	player.x=player.x+player.xd
	camera.target(player.x) --smoothly interpolate the camera
	--subtract the timers
	player.time=player.time-1
	player.runtime=player.runtime+1
	--game over
	if (player.time < 0) then
		gmode.set(gmode.time_over)
		return
	end
	--score is always ticking down, always
	player.score=player.score-10
	player.score_gain=player.score_gain-10
	if player.score<0 then player.score=0 end
	--unlimited time, makes testing easier
	if astro_burst_debug then
		player.time=60*20
	end
end

--draw the player
--TODO: kinda should see if I can nudge this somewhere in the object drawing routine so it's z-ordered properly instead of always in front of objects
player.draw = function()
	local rx,ry,rs=camera.get2D(player.x,0,player.z)
	local anim=0
	if (t%7 >5) then anim=1 end
	--shake when near max speed
	if player.speed > player.maxspeed_normal[speed_class]*0.95 and t%2==0 then
		ry=ry+1
	end
	spr(rx,ry,rs,0,anim)
end

--reset most things
function init_most()
	moon.init()
	camera.init()
	objects.init()
	player.init()
	particles.init()
	stars.init()
	t=0
	flip=1;
	clock_big=0
end

--reset the whole game
function init()	
	gmode.init()
	levels.init()
	init_most()
end

--the moon/planet/satellite in the background
moon={}
moon.init=function()
	moon.ty=math.random(0,1) --pick a sprite
	moon.s=math.random(250,360)/100 --each race takes place somewhere random in space, so have different sized objects (TODO: each stage should probably be consistent, so maybe we should set the random seed based on the stage number?)
end

--the moon is always actually pretty close here, so give it some (exaggerated) parallax
moon.draw=function()
	local rx,ry,rs=camera.get2D(-200000,-100000,6000)
	spr(rx,ry,moon.s,4,moon.ty)
end

--game mode stuff
gmode={}
gmode.warning={} --photosensitivity warning
gmode.title={} --title screen
gmode.time_over={} --game over
gmode.ingame={} --main game loop
gmode.pause={} --pause/exit menu
gmode.stage_select={} --pick a stage+difficulty
gmode.stage_clear={} --end of level
gmode.attract={} --make it so the title screen doesn't just sit there forever

--resets the game to the title
gmode.init=function()
	gmode.current=gmode.warning
end

--change game mode and do initialization
gmode.set=function(m)
	gmode.current=m
	gmode.current.init()
end

--change game mode, no init (used for stuff like pausing)
gmode.swap=function(m)
	gmode.current=m
end

--clears the screen, updates based on game mode
function step()
	cls_grad(sc[speed_class].bg.r, sc[speed_class].bg.g, sc[speed_class].bg.b)
	gmode.current.step()
	t=t+1
	flip=-flip
end

--switch to the next attract segment
--c is the index, g is the gap
gmode.attract.go=function(c,g)
	local this=gmode.attract
	this.current=c
	if g then
		this.gap=g
	else
		this.gap=10
	end
	this.time=0
end

--attract sequence
--this entire bit of code is hideous and supremely ad-hoc and you'll probably want a better structure if you decide to add an attract sequence to your own games
--although, I do like how I separated it into sections and how nice and automatic it works, but it's still not anything resembling a robust animation system
--this code only gets away with being like this because it's not actually interactive at all; it's all very fragile
--half tempted to design a second attract, but I should probably put a how-to-play screen there then
gmode.attract.init=function()
	local this=gmode.attract --I wrote this before I was better at Lua, it really should be something like gmode.attract.init=function(this) or whatever and I'd call gmode.attract:init(), but whatever
	--each of the individual parts, it's a table full of functions
	this.section={}
	--scrolling stars, "high speed space race" slides in
	this.section[1]=function()
		player.speed=-3
		particles.addDirect(
			math.random(-8000,8000),
			math.random(-8000,8000),
			20,
			math.random(64,128),
			math.random(64,128),
			math.random(64,128)
		)
		particles.update()
		particles.draw()
		this.maxtime=90
		local tpos={}
		stars.offset_x=this.time/10
		stars.offset_y=this.time/5
		stars.draw()
		tpos[1]=math.max(0,view_width-this.time*35)
		tpos[2]=math.max(0,view_width+128-this.time*30)
		tpos[3]=math.max(0,view_width+256-this.time*27)
		tpos[4]=math.max(0,view_width+384-this.time*23)
		text("high",tpos[1],0,4,0)
		text("speed",tpos[2],8*4,4,0)
		text("space",tpos[3],8*4*2,4,0)
		text("race",tpos[4],8*4*3,4,0)
	end
	--expanding road, "beat the clock", reddening sky
	this.section[2]=function()
		this.maxtime=90
		if this.time==0 then
			particles.init()
			player.init()
		end
		particles.addDirect(
			math.random(-8000,8000),
			math.random(-8000,8000),
			200,
			8,
			16,
			32
		)
		particles.addDirect(
			math.random(-8000,8000),
			math.random(-8000,8000),
			200,
			64,
			32,
			8
		)
		particles.update()
		player.speed=9
		if t%2==0 then
			objects.add(0,600+this.time*40,0)
		end
		camera.x=math.random(-30,30)
		cls(this.time*0.8,4,12)
		objects.update()
		objects.draw()
		particles.draw()
		text(
			"beat the clock! beat the clock! beat the clock! beat the clock!",
			-this.time*4,
			view_height/2-48,
			3,
			0
		)
		local bwflash=1
		if this.time%40>=20 then bwflash=0 end
		text(
			"beat the clock! beat the clock! beat the clock! beat the clock!",
			this.time*2-228,
			view_height/2-48-8,
			1,
			bwflash
		)
	end
	--more scrolling stars, "fastest in the galaxy" text slides into view
	this.section[3]=function()
		this.maxtime=80
		if this.time==0 then
			stars.init()
			this.shake=0 --lua lets me get away with this kind of thing for some reason
		end
		local shakeval = this.shake
		if this.time%2==0 then shakeval=-shakeval end
		stars.offset_x=stars.offset_x+shakeval
		stars.draw()
		stars.offset_x=stars.offset_x-shakeval
		if this.time>=5 then
			if this.time==5 then this.shake=5 end
			text("fastest",shakeval,0+8,4,1)
		end
		if this.time>=20 then
			if this.time==20 then this.shake=7 end
			text("in",shakeval,8*4+8,4,0)
		end
		if this.time>=35 then
			if this.time==35 then this.shake=10 end
			text("the",shakeval,8*4*2+8,4,0)
		end
		if this.time>=50 then
			if this.time==50 then this.shake=15 end
			text("galaxy",shakeval,8*4*3+8,4,0)
		end
		--added offset_x/y just so I could do this
		--might set the stars to wrap, so they can be infinitely scrolled
		stars.offset_x=stars.offset_x-0.0625
		stars.offset_y=stars.offset_y-0.25
		if this.shake>0 then this.shake=this.shake-1 end
	end
	--big shaking text, "get ready for"
	--has a dramatic screen flash to white that I hope isn't too intense -- yes, the player was warned at the start, but we're trying to look cool, not hurt people
	this.section[4]=function()
		this.maxtime=220
		if this.time==0 then
			stars.init()
			this.shake=0 --lua lets me get away with this kind of thing for some reason
		end
		local cur_str=""
		local cur_mode=0
		local rng_pow=1
		local shakeval = this.shake
		if this.time%2==0 then shakeval=-shakeval end
		cls(255,255,255)
		if this.time==0 then
			particles.init()
			player.init()
			player.speed=1
		end
		--get
		particles.add(math.random(-8000,8000), math.random(-8000,8000), 32,96)
		particles.update()
		if this.time>=5 and this.time<20 then
			particles.draw()
			if this.time==5 then
				this.shake=5
			end
			cur_str="get"
			cur_mode=1
			rng_pow=0
			player.speed=1
		end
		--ready
		if this.time>=20 and this.time < 35 then
			particles.draw()
			if this.time==20 then
				this.shake=10
			end
			cur_str="ready"
			cur_mode=0
			rng_pow=1
			player.speed=3
		end
		--for
		if this.time>=35 and this.time < 50 then
			if this.time==35 then
				this.shake=15
			end
			particles.add(math.random(-8000,8000), math.random(-8000,8000), 32,96)
			cls(0,0,0)
			particles.draw()
			cur_str="for"
			cur_mode=1
			rng_pow=3
			player.speed=5
		end
		--[astro-burst]
		if this.time>=50 then
			if this.time==50 then
				this.shake=20
			end
			player.speed=9
			particles.add(math.random(-8000,8000), math.random(-8000,8000), 32,96)
			particles.add(math.random(-8000,8000), math.random(-8000,8000), 32,96)
			rng_pow=1
			cls(0,12,24)
			particles.draw()
			cur_str=""
			cur_mode=2
			text(
				"[astro-burst]",
				shakeval+view_width/2-16*13/2+math.random(-rng_pow,rng_pow), math.random(-rng_pow,rng_pow)+view_height/2-8,
				2,
				3
			)
		end
		--draw the current part's message
		--doesn't draw the [astro-burst] text, since it's a different size and behaves differently
		text(
			cur_str,
			view_width/2-(8*string.len(cur_str)*5)/2+math.random(-rng_pow,rng_pow),
			view_height/2-(8*5)/2+shakeval,
			5,
			cur_mode
		)
		--shake countdown
		if this.shake>0 then this.shake=this.shake-1 end
	end
	--go to the title now that all is done
	this.section[5]=function()
		gmode.set(gmode.title)
		return
	end
	--reset everything
	player.init()
	camera.init()
	objects.init()
	particles.init()
	stars.init()
	--timing and indexing, then kick it all off
	this.current=1
	this.gap=0
	this.time=0
	this.maxtime=90 --don't assume this was set, but 90f is reasonable
	this.go(1)
end

--run each attract screen segment
gmode.attract.step=function()
	local this=gmode.attract
	--we used to use the current speed class background but it was a bit ugly
	cls_grad(sc[3].bg.r,sc[3].bg.g,sc[3].bg.b,false)
	--small gap between attract scenes to make it punchier
	if this.gap>0 then
		this.gap=this.gap-1
	--run a frame for the current scene
	else
		this.section[this.current]()
		this.time=this.time+1
	end
	--immediately cut to the title if the player hits start
	if key(key_start)==1 then
		gmode.set(gmode.title)
		return
	end
	--go to the next scene when the current one is over
	if this.time>this.maxtime then
		this.current=this.current+1
		this.go(this.current)
	end
end

--title screen
gmode.title.init=function()
	player.init()
	camera.init()
	objects.init()
	particles.init()
	stars.init()
	t=0
end
--update the title screen
gmode.title.step=function()
	--kick back to the attract screen if we just leave it here
	if t>60*15 then
		gmode.set(gmode.attract)
		return
	end
	--start game
	--TODO: this should have three options, start, settings, and how to play
	--might stick that in a separate screen though
	if key(key_start)==1 then
		gmode.set(gmode.stage_select)
		return
	end
	--add some particles
	if flip>0 then
		particles.add(math.random(-8000,8000), math.random(-8000,8000), 32,96)
	end
	--constantly add road
	if t%10==0 then
		objects.add(0,3000,0)
	end
	--general update
	objects.update()
	stars.draw()
	moon.draw()
	player.speed=1 --the road movement depends on player speed
	objects.draw()
	particles.update()
	particles.draw()
	rect(0,0,16,16,255,255,255) --fixes a weird glitch with the text, I need to look into what's happening, could be the result of SDL2's software scaling being a bit bugged with clipping around the edges
	--scrolling labels
	--TODO: actually make scrolling text a built-in feature for quig
	text("astro-burst astro-burst astro-burst astro-burst ",-15*12-((t//4)%(16*12)),0,2,0)
	text("2022 B.M.Deeal\n-beta version-",0,16,1,1)
	--flashing start text
	--TODO: this should be a menu
	if t%60 > 12 then
		text("[press start button]",(view_width-20*8)/2,view_height-12,1,2+flip)
	end
end

--draw the disqualification clock
function draw_clock(flash)
	--clock scales based on how much of the current second has elapsed
	local clock_scale=math.max(math.max((player.time%60)/60*2.8,2),clock_big/60*3.5)
	--flash clock when time is low, don't flash while we're picking up checkpoint time
	local low_time=0
	if flash or (player.time < 9*60 and player.time%50>=25 and clock_big<10) then
		low_time=1
	end
	--shrink clock from an external source (basically just checkpoints)
	if clock_big > 0 then clock_big=clock_big-1 end
	--draw the clock and underlying text
	text(string.format("%02d", player.time//60),view_width/2-8*clock_scale,0,clock_scale,1-low_time)
	--the underlying text additionally warns you when time is VERY low/empty
	local timestr="time"
	if player.time>0 then
		if t%40>=20 and player.time<60*5 then
			timestr="low!"
		end
	elseif t%200>=100 then
		timestr="over"
	end
	text(timestr,view_width/2-8*clock_scale,8*clock_scale,clock_scale/2,3)
end

--set up the game loop
gmode.ingame.init=function()
	init_most()
	splits.init()
	local this=gmode.ingame
end

--game loop
gmode.ingame.step=function()
	local this=gmode.ingame
	--a burst of particles, even when not moving
	if (t%100 < 4) then
		particles.add(math.random(-2000,2000), math.random(-2000,2000), 32,96)
	end
	--if the player has advanced far enough forward, generate a new part of the level
	if player.counter > player.countertop then
		splits.update()
		particles.add(math.random(-4000,4000), math.random(-3000,3000), 8,48)
		local ww,oo,ff=levels.get()
		objects.add(oo,ww,ff)
		player.counter=player.counter-player.countertop
	end
	--update and draw
	stars.draw()
	moon.draw()
	player.update()
	objects.update()
	particles.update()
	objects.draw()
	player.draw()
	particles.draw()
	splits.draw()
	--hud stuff
	--FPS display (TODO: move to a function?):
	text("fps:"..math.floor(getfps()*100)/100,0,view_height-8,1,1)
	--TODO: proper debug indicator setup
	--text("x" .. player.x .. " speed" .. player.speed*10//1/10,0,8,1,1)
	--text("i" .. levels.index.."\nw" .. player.width .. "\no"..player.offset .. "\n"..(t/60//60) .. ":" .. (t//60%60), 0,8,1,1)
	--draw the lap time
	text(">"..timeToString(player.runtime),0,0,1,1)
	--draw the score+score gain indicator
	text(string.format("sc:%08d",player.score),view_width-8*11,0,1,1)
	text(string.format("%+04d", player.score_gain_last), view_width-8*4,8,1,3)
	draw_clock()
	--draw player speed
	local pspeed=string.format("%03d",player.speed*100//1)
	text("spd",view_width-9*8,view_height-16,1,2+flip)
	text(pspeed,view_width-6*8,view_height-16,2,2+flip)
	--draw out-of bounds text
	if not oobt then oobt=0 end --dirty hack
	--we show the oob stuff for a few frames after returning to the track
	if player.oob then
		player.oobtimer=20
	end
	if player.oobtimer>0 then
		oobt=oobt+1 --instead of using the game timer, we use an internal one that resets when in bounds
		--the left side text flashes
		local oobflash=0
		if oobt%80<40 then
			oobflash=1
		end
		--the right side text changes depending on time remaining
		--also, it blinks
		if oobt%25<15 then
			local tcol=1
			local tmsg="caution"
			if player.time<60*10 then
				tmsg="warning"
			end
			--message becomes white when in serious danger
			if player.time<60*5 then
				tmsg="danger!"
				tcol=0
			end
			--draw right side message
			text("(!) "..tmsg,view_width-8*11-16,44,1,tcol)
		end
		--draw left side message
		text("out of\nbounds!", 16, 32, 2, oobflash)
		player.oobtimer=player.oobtimer-1
	else
		--reset out-of-bounds running timer
		oobt=0	
	end
	--handle game pausing
	if key(key_start)==1 then
		gmode.set(gmode.pause)
		return
	end
end

--game pausing
gmode.pause.quit=false
--set up the two pause menu selections
gmode.pause.init=function()
	gmode.pause.quit=false
	gmode.pause.confirm=false
end
--update the pause screen
gmode.pause.step=function()
	local this=gmode.pause
	local txtoffset=28
	--different background when quitting
	if this.confirm then
		cls_grad(32,0,0)	
	end
	stars.draw()
	moon.draw()
	objects.draw()
	player.draw()
	particles.draw()
	--lots of scrolling stuff
	--doing this makes me think I should consider adding scrolling text directly to quig as a command
	text("astro-burst astro-burst astro-burst astro-burst ", -8*12+(t%(8*12))+1,40-txtoffset-1,1,2)
	text("astro-burst astro-burst astro-burst astro-burst ", -8*12+(t%(8*12)),40-txtoffset,1,3)
	--different scrolling text based on whether we're confirming quit
	local sctxt="[pause] [pause] [pause] [pause] "
	if this.confirm then
		sctxt="[quit?] [quit?] [quit?] [quit?] "
	end
	text(sctxt, -(t%(8*8*3)),48-txtoffset,3,0)
	--pause menu, ask yes/no questions
	local conftxt="press A-button to confirm"
	text(conftxt, view_width-8*#conftxt+1,88-txtoffset-1,1,2)
	text(conftxt, view_width-8*#conftxt,88-txtoffset,1,3)
	--draw the quit message alongside the player's choice
	local sctxt2="quit?   "
	if this.confirm then
		sctxt2="sure?   "
	end
	text(sctxt2,view_width-7*16-4,72-txtoffset,2,1)
	text("no",view_width-3*8,72-txtoffset,1,1)
	text("yes",view_width-3*8,72-txtoffset+8,1,1)
	local sel_offset=0
	--handle the cursor
	if gmode.pause.quit then sel_offset=8 end
	if not gmode.pause.arrowx then gmode.pause.arrowx=0 end
	if t%30 == 10 then gmode.pause.arrowx=-10 end
	gmode.pause.arrowx=target(0,gmode.pause.arrowx,7)
	text(">",view_width-4*8+gmode.pause.arrowx,72-txtoffset+sel_offset,1,1)
	--select up/down
	if key(key_down)==1 then
		gmode.pause.quit=true
	end
	if key(key_up)==1 then
		gmode.pause.quit=false
	end
	--handle exit
	if key(key_start)==1 or key(key_a)==1 then
		if this.confirm then --handle exit confirmation
			if this.quit then
				gmode.set(gmode.title)
			else
				this.confirm=false
			end
		else --normal pause
			if this.quit then
				this.confirm=true
			else
				gmode.swap(gmode.ingame)
			end
		end
		this.quit=false
	end
end

--out of time, game over
gmode.time_over.init=function()
	log_score()
	for ii=1,particles.max do
		particles.add(math.random(-8000,8000), math.random(-8000,8000), 32,96)
	end
	player.time=0
end

--this is in a function because there used to be more than one when designing the time over screen
function timeover_bar(y,scale,speed,mode)
	local twidth=8*13*scale
	text("time over... time over... time over... time over... time over...",-twidth-((t*speed)%twidth),y,scale,mode)
end

--handle the game over screen
gmode.time_over.step=function()
	cls(8,8,16)
	if player.speed<0.1 then player.speed=-0.1 end
	player.xd=0
	camera.target(player.x)
	objects.update()
	objects.draw()
	player.draw()
	particles.update()
	particles.draw()
	player.time=0
	local flash=false
	if t % 60 > 30 then flash=true end 
	draw_clock(flash)
	timeover_bar((view_height-8*3)/2,3,1,1)
	text("press start button...",0,view_height-8,1,0)
	text(string.format("final score: %08d",gmode.stage_clear.clear_score),0,view_height-16,1,2+flip)
	if key(key_start)==1 then
		gmode.set(gmode.title)
		return
	end
end

--log best score
--TODO: this should set a flag indicating if this run had the best score or not
function log_score()
	gmode.stage_clear.clear_score=player.score --the score ends up getting updated after the goal so let's pretend that doesn't happen
	if (not best_scores[speed_class][gmode.stage_select.selection]) or gmode.stage_clear.clear_score > best_scores[speed_class][gmode.stage_select.selection] then
		best_scores[speed_class][gmode.stage_select.selection] = gmode.stage_clear.clear_score
	end
end

--log best time
function log_time()
	if (not best_times[speed_class][gmode.stage_select.selection]) or player.runtime < best_times[speed_class][gmode.stage_select.selection] then
		best_times[speed_class][gmode.stage_select.selection] = player.runtime
	end
end

--setup the end of stage screen
forward_adjust=0 --TODO: what is this for
gmode.stage_clear.clear_score=0
gmode.stage_clear.init=function()
	forward_adjust=0 --scrolling
	log_time()
	log_score()
end

--handle the end of stage screen
gmode.stage_clear.step=function()
	--force the player into the middle of the goal area
	--this looks goofy if you hit the goal while going really slow and are far from the middle
	local hmove=20
	if player.x > player.offset+1 or player.x < player.offset-1 then
		player.x=(player.offset+player.x*hmove)/(hmove+1)
	end
	--continue tracking the player
	camera.target(player.x)
	--slow the player down so they settle right in
	if player.speed > 3 then player.speed=3 end
	player.speed=player.speed-0.03
	if player.speed<0 then player.speed=0 end
	--background
	stars.draw()
	moon.draw()
	--victory particles
	if flip>0 then
		particles.add(math.random(-8000,8000), math.random(-8000,8000), 32,96)
	end
	--particles not drawn over everything anymore -- this is deliberate
	particles.draw()
	particles.update()
	--draw the road, player
	objects.update()
	objects.draw()
	player.draw()
	--draw player clear time
	local txt_scale=2.5+math.sin(t/40)*0.5
	if t%40>10 then
		text(timeToString(player.runtime), 0,0,2,1)
	end
	--big stage clear banner, with a rectangle for the background
	local scx, scy
	scx=0-(t*txt_scale*0.8)%(8*13*txt_scale)
	scy=(view_height-40)
	rect(0,scy+2,view_width,7*txt_scale,0,0,0)
	text("stage clear! stage clear! stage clear! stage clear! ",scx,scy,txt_scale,3)
	--best time
	local bt_text=""
	if player.runtime == best_times[speed_class][gmode.stage_select.selection] then
		bt_text="new "
	end
	text(bt_text .. "best:" .. timeToString(best_times[speed_class][gmode.stage_select.selection]), 0,16,1,1)
	--current score
	text(string.format("c.sc:%08d", gmode.stage_clear.clear_score), 0,24,1,1)
	--best score
	local hs_text=""
	--TODO: this keeps showing "new" even if you have an identical score/time, fix that maybe
	if gmode.stage_clear.clear_score == best_scores[speed_class][gmode.stage_select.selection] then
		hs_text="new "
	end
	text(string.format(hs_text.."best:%08d", best_scores[speed_class][gmode.stage_select.selection]), 0,32,1,0)
	--return to title
	text("[press start button]",view_width-20*8,view_height-8,1,0)
	if key(key_start)==1 then
		gmode.set(gmode.title)
		return
	end
end

--warning text+copyright info
--largely a courtesy, the attract mode is flashy, but the whole game is fairly flashy
--TODO: the actual warning text is a bit... non-descriptive
gmode.warning.init=function()
	init_most()
end

--show the warning
gmode.warning.step=function()
	cls(50,50,50)
	spr(view_width-16,view_height-16,2,0,0)
	text("Welcome to astro-burst!",0,0,1,0)
	text("\n(C) 2022 B.M.Deeal\nLicensed under GPLv3.\n\n---\n\n\n\nThis game features flickering\nlights and flashing imagery.\nPlayer discretion is advised.",0,8,1,3)
	text("\nPhotosensitivity warning:",0,8*6,1,0)
	text("press start to play...",0,view_height-8,1,1)
	if key(key_start)==1 then
		gmode.set(gmode.attract) --asdf
		return
	end
end

--stage select screen stuff
gmode.stage_select.selection=1 --what stage was picked
gmode.stage_select.shift=0 --location of the selected stage text
gmode.stage_select.classgrow=1 --how much to scale the speed class text (visual indication when selecting it)
--set up a few things
gmode.stage_select.init=function()
	local this=gmode.stage_select
	init_most()
	this.shift=view_width
	gmode.stage_select.classgrow=1
	--particles.init()
end

--update stage select screen
gmode.stage_select.step=function()
	local this=gmode.stage_select
	--show some stars since it looked a bit plain without them
	--no moon
	stars.draw()	
	--show some particles (these are a nice visual indication of the current speed class, too)
	if flip>0 then
		particles.add(math.random(-12000,12000), math.random(-6000,6000), 32,96)
	end
	player.speed=speed_class
	particles.update()
	particles.draw()
	
	--top text
	text("stage", view_width-8*5-6*16,0 ,1, 0)
	text("select", view_width-6*16,0 ,2, 1)
	
	--draw which speed class we're on
	local scpx, scpy, scpw, scph --holds the positions for the speed class text
	scpw=#sc[speed_class].name*8 * this.classgrow --width
	scph=8*this.classgrow --height
	scpx=view_width-scpw --x-pos
	scpy=(view_height+32)/2-scph-3 --y-pos
	--this is a dirty hack around a quig text scaling bug where gaps appear in the filled background text modes that will eventually get fixed... but it isn't fixed right now
	rect(scpx,scpy,scpw+1,scph+1,255,255,255)
	--draw the selected speed class
	text(sc[speed_class].name, scpx,scpy,this.classgrow,0)
	--automatically shrink the speed class text
	if this.classgrow > 1 then
		this.classgrow=this.classgrow-0.125
	end
	if this.classgrow<1 then --bounds check
		this.classgrow=1
	end
	
	--pick speed class
	if key(key_up)==1 then --slower
		if speed_class > 1 then
			speed_class=speed_class-1
			this.classgrow=2
		else --animate less if we're already at the end of the list
			this.classgrow=1.5
		end
	elseif key(key_down)==1 then --faster
		if speed_class < 7 then
			speed_class=speed_class+1
			this.classgrow=2
		else
			this.classgrow=1.5
		end
	end
	--crazy shaking on absurd
	if speed_class>=6 and this.classgrow<1.4 then
		this.classgrow=math.min(3, this.classgrow+math.random()*0.065)
	end
	
	--pick stage, have it slide in smoothly
	if key(key_left)==1 then
		this.selection= this.selection-1
		this.shift=view_width
	end
	if key(key_right)==1 then
		this.selection= this.selection+1
		this.shift=view_width
	end
	
	--clamp stages
	if this.selection<1 then this.selection=stages end
	if this.selection>stages then this.selection=1 end
	
	--show best score if it exists
	if best_scores[speed_class][this.selection] then
		local bsstr = "best score:" .. math.floor(best_scores[speed_class][this.selection])
		text(bsstr,1,(view_height+32)/2-3-16-1,1,2)
		text(bsstr,0,(view_height+32)/2-3-16,1,3)
	end
	
	--show best time if it exists
	local btstr=""
	if best_times[speed_class][this.selection] then
		btstr = "best time:" .. timeToString(best_times[speed_class][this.selection])
	else
		btstr = "not yet cleared..."
	end
	text(btstr,1,(view_height+32)/2-3-8-1,1,2)
	text(btstr,0,(view_height+32)/2-3-8,1,3)
	--divider line
	rect(0,(view_height+32)/2-3,view_width,3,255,255,255)
	--selected stage
	text(""..this.selection.."/"..stages, this.shift, (view_height+32)/2,4,0)
	--control description (TODO: this could look nicer)
	text("left/right: select stage\nup/down: select speed\npress A-button to start",2,view_height-24+2,1,2)
	text("left/right: select stage\nup/down: select speed\npress A-button to start",0,view_height-24,1,3)
	--slide in the selected stage
	this.shift=target(0, this.shift, 6)
	--select a stage
	if key(key_a)==1 then
		if levels.create[this.selection] then
			levels.create[this.selection]()
			gmode.set(gmode.ingame)
			return
		else
			cls(0,0,0)
		end
	end
	--TODO: this is only for testing, really should remove this at some point
	--debug stage
	--if key(key_start)==1 then
	--	this.selection=0
	--	levels.create[this.selection]()
	--	gmode.set(gmode.ingame)
	--	return
	--end
	--return to title
	if key(key_b)==1 then
		gmode.set(gmode.title)
		return
	end
end
