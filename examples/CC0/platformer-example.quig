--name of game: platform game example
--game author: B.M.Deeal <brenden.deeal@gmail.com>
--this file licensed under CC0; NO WARRANTY
--see <https://creativecommons.org/publicdomain/zero/1.0/> for details

--[[
	This example is a quick and dirty starting place to make your own platform game with.
	You might end up replacing some/all of it, but it's intended as a starting point, rather than a finished game.
	
	A lot of this is based on code I wrote nearly a decade ago (in particular, the way colliding with walls is handled).
	It works reasonably well, but has an actual, literal corner case that is handled in a very ugly and somewhat awkward way.
	Fixing this is currently left as an exercise to the reader. :P
	
	This game calls into question the decision in quig to make the standard sprite drawing offset the center, since it needs to be accounted for... but any choice of a default offset would cause issues with different types of games.
	
	---
	
	IDEAS TO TRY (for the reader possibly, unless I decide to throw these in):
	* animation -- just change the player sprite every few frames
	* jump forgiveness -- if you're not on a platform, add a few frames where you can jump in mid air, like a cartoon character that hasn't realized that it's falling
	* semi-solid platforms -- if you're moving downwards from above, they're solid, but otherwise, the player can ignore them
	* moving platforms -- update the player's position as they move
	* scrolling camera -- think of the camera in Sonic CD, how it smoothly shifts to view more of the level when you've been moving for a while, and re-centers when you slow back down
	* zooming camera -- alternatively, zoom the camera in/out dynamically? this one may have issues with tile positioning gaps, but it's worth a try, and you could draw tiles slightly larger than normal to counteract that
--]]

--is the game paused?
paused=false

--get whether a number is negative (returns -1), positive (returns 1), or zero (returns 0)
--still don't know why this isn't in the lua math.* library
function sign(n)
	if n>0 then return 1 end
	if n<0 then return -1 end
	return 0
end

--limit a value from 0-255, rounded down
function clamptobyte(c)
	return math.floor(math.max(0,math.min(255,c)))
end

--draw a fullscreen linear gradient between two colors
function gradient_bg(r1,g1,b1,r2,g2,b2)
	local width=2 --thinner width looks better, but is slower
	local bands=math.ceil(view_height/width) --how much we need to loop
	local rs, gs, bs = (r2-r1)/bands, (g2-g1)/bands, (b2-b1)/bands --how much to change each color over the loop
	for ii=0,bands do
		rect(
			0,
			width*ii,
			view_width,
			width,
			clamptobyte(r1),
			clamptobyte(g1),
			clamptobyte(b1)
		)
		r1, g1, b1= r1+rs, g1+gs, b1+bs
	end
end

--tiles to draw on screen
--this isn't really a tilemap, rather, it's a bunch of sprites
tiles={}
--setup the tile list, this should get called at the start of each stage
tiles.init=function(self)
	--how many tiles are in the stage
	self.count=0
	--actual list of tiles
	self.map={}
	--how to scroll everything
	--anything that needs to scroll alongside the level should be affected by tiles.x/tiles.y
	self.x=0
	self.y=0
	self.x_offset=0
end

--add a tile
--offset is how far from the next tile, in 16x16 spaces
--ypos is spaces from the bottom of the screen, again in 16x16 spaces
--scale is the size of the block -- 1 is 16x16, 2 is 32x32, etc, etc
--offset and ypos are still floating point numbers, so you can still do offsets
--kind is what object type to add (see list below)
tiles.typeBlock=0
tiles.typeSpring=1
tiles.typeGoal=2
tiles.add=function(self, offset, y, scale, kind)
	if kind==nil then kind=0 end
	if scale==nil then scale=1 end
	self:addOffset(offset*16)
	self.count=self.count+1
	self.map[self.count]={
		--undo the center offset -- quig sprites are drawn centered, this shifts back to the top-left corner
		x=self.x_offset+8*scale,
		y=(view_height-(y*16+8*scale)),
		--set the kind, but we set the texture offset elsewhere
		kind=kind,
		---current sprite
		tx=1,
		ty=0,
		--sprite to use when not colliding
		tx1=1,
		ty1=0,
		--sprite to use when colliding (eg, springs)
		tx2=1,
		ty2=0,
		--timer before resetting the sprite
		spr_time=0,
		spr_time_max=4,
		--you probably shouldn't use non-integer scales for tiles (it looks ugly and will have positioning issues), but it's not enforced
		scale=scale
	}
	target=self.map[self.count]
	--set the sprites for each object type
	--look for "tiles.type" to find the list in this file
	if kind==tiles.typeSpring then
		target.tx1=3
		target.ty1=0
		target.tx2=4
		target.ty2=0
	elseif kind==tiles.typeGoal then
		target.tx1=2
		target.ty1=0
		target.tx2=2
		target.ty2=0
	--elseif kind==tiles.type... then
	end
	target.tx=target.tx1
	target.ty=target.ty1
end

--add to the offset for the next tile, in pixels
tiles.addOffset=function(self, offset)
	self.x_offset=self.x_offset+offset
end

--draw all the tiles
--TODO: stop drawing tiles that are off screen
tiles.draw=function(self)
	--loop through and draw each tile
	for ii=1,self.count do
		other=self.map[ii]
		spr(
			other.x+self.x,
			other.y+self.y,
			other.scale,
			other.tx,
			other.ty
		)
		--only update the on-collision animation if we aren't paused
		if not paused then
			if other.spr_time>0 then
				other.spr_time=other.spr_time-1
			else
				other.tx=other.tx1
				other.ty=other.ty1
			end
		end
	end
end

--handle levels
--there is really only one level, but it's setup as if there were more
--tiles:add has 4 parameters (all units are multiples of 16px):
--> offset from previous object
--> offset from bottom of screen
--> scale of object
--> type of object, can be omitted to place a wall (tiles.typeBlock)
levels={}
levels[1]=function()
	tiles:init()
	tiles:add(0,0,4)
	tiles:add(4,0,4)
	tiles:add(4,0,2)
	tiles:add(1,2,1,tiles.typeSpring)
	tiles:add(3,1,2)
	tiles:add(3,2,2)
	tiles:add(0,4,1,tiles.typeSpring)
	tiles:add(3,1,2)
	tiles:add(2,0,2)
	tiles:add(2,0,2)
	tiles:add(0,4,1)
	tiles:add(2,0,2)
	tiles:add(2,0,2)
	tiles:add(2,2,2)
	tiles:add(0,0,2)
	tiles:add(2,4,2)
	tiles:add(0,2,2)
	tiles:add(0,0,2)
	tiles:add(3.5,1,2)
	tiles:add(0,3,1,tiles.typeSpring)
	tiles:add(3,3,1)
	tiles:add(2.25,3,tiles.typeSpring)
	tiles:add(2.25,2,tiles.typeSpring)
	tiles:add(2.25,1,tiles.typeSpring)
	tiles:add(3,0,4)
	tiles:add(6,1,4)
	tiles:add(6,0,4)
	tiles:add(2,4,2,tiles.typeGoal)
	tiles:add(2,0,4)
	tiles:add(4,0,4)
end

--player character
player={}
--initialize the player object
player.init=function(self)
	--current position
	self.x=16
	self.y=0
	--player state
	self.ground=0
	self.jump=0
	--previous position without a collision
	self.xprev=0
	self.yprev=0
	--how much to move this frame
	self.xd=0
	self.yd=0
	--physics
	self.gravity=0.30 --fall speed
	self.friction=0.125 --only affects horizontal speed
	self.max_speed_x=1.5
	self.max_speed_y=5.5
	self.accel=0.25 --how fast to accelerate horizontally, must overcome friction
	self.jump_strength=3 --how much to move by each frame during a jump
	self.jump_time=0 --how long you've held a jump
	self.jump_max=9 --how long in frames you can hold a jump
end

--handle player movement, collision, and physics
player.update=function(self)
	--handle collisions with other objects
	local others=self:getCollisions(0,0)
	--bounce off of springs
	--TODO: kinda want to make it so that you move at a slower, but fixed rate upwards vs just immediately being launched
	if others[tiles.typeSpring] then
		self.yd=-5.5
	end
	--reset on hitting the goal
	if others[tiles.typeGoal] then
		init()
		return
	end
	--check if we're standing on the ground
	if self:getCollisions(0,1)[0] then
		self.ground=true
	else
		self.ground=false
	end
	--check if we've bounced off the ceiling (also, don't bother allowing jumping if there's no room)
	if self:getCollisions(0,-1)[0] then
		self.jump_time=0
	end
	--move left/right
	if key(key_left)>0 then
		self.xd=self.xd-self.accel
	end
	if key(key_right)>0 then
		self.xd=self.xd+self.accel
	end
	--jump
	--begin a jump when you press the A-button on the ground
	if key(key_a)==1 and self.ground and not jump then
		self.jump=true
	end
	--continue rising until you let go/run out of jump time
	if key(key_a)>0 and self.jump and self.jump_time>0 then
		self.yd=-self.jump_strength
		self.jump_time=self.jump_time-1
	else
		self.jump=false
	end
	--slow the player down horizontally
	if math.abs(player.xd)>=player.friction then
		player.xd=player.xd-sign(player.xd)*player.friction
	else
		player.xd=0
	end
	--fall down
	if not self.ground then
		self.yd=self.yd+self.gravity
	end
	--clamp speed
	if self.xd > self.max_speed_x then
		self.xd=self.max_speed_x
	end
	if self.xd < -self.max_speed_x then
		self.xd=-self.max_speed_x
	end
	if self.yd > self.max_speed_y then
		self.yd=self.max_speed_y
	end
	if self.yd < -self.max_speed_y then
		self.yd=-self.max_speed_y
	end
	--we save the sign of each direction for use when resolving the corner case 
	local xds = sign(self.xd)
	local yds = sign(self.yd)
	--resolve collision with walls -- we just check if the space we're about to enter is a wall, and if so, we inch towards, pixel-by-pixel
	--horizontally
	if self:getCollisions(self.xd, 0)[0] and sign(self.xd) ~=0  then
		while (not self:getCollisions(sign(self.xd),0)[0]) do
			self.x=self.x+sign(self.xd)
		end
		self.xd=0
	end
	--vertically
	if self:getCollisions(0, self.yd)[0] and sign(self.yd) ~=0  then
		self.y=math.floor(self.y) --if you don't do this, there's sometimes a gap between the player and the floor; there is almost certainly a similar glitch with horizontal movement that is less noticeable
		while (not self:getCollisions(0,sign(self.yd))[0]) do
			self.y=self.y+sign(self.yd)
		end
		self.yd=0
	end
	--solve the literal corner case (eg, when you hit the corner of a block)
	--a bit jarring, but prevents the player from getting stuck on corners
	--TODO: there's a better way to handle this
	if self:getCollisions(0,0)[0] then
		--if we're stuck in a wall and weren't moving for whatever reason, jump to the most recent safe position
		if xds==0 and yds==0 then
			self.x=self.xprev
			self.y=self.yprev
		--otherwise, move out from the collision, roughly based on the last movement direction
		else
			while self:getCollisions(0,0)[0] do
				self.x=self.x-xds
				self.y=self.y-yds
			end
		end
	--save the last safe position	
	else
		self.xprev=self.x
		self.yprev=self.y
	end
	--update player position after all is done
	self.x=self.x+self.xd
	self.y=self.y+self.yd
	--restore jumping on the ground
	if (self.ground) then
		self.jump_time=self.jump_max
	end
	--clamp position horizontally against the left side of the screen
	if self.x<8 or self.x-self.xd<8 then --the magic number 8 here is is half the width of a quig sprite, which is 16x16, and sprites are positioned by their center
		self.x=8
		self.xd=0
	end
	--restart game when falling out of the level
	if self.y>view_height+8 then
		init()
	end
	--scroll the tiles to match the player's position, but don't scroll behind the left edge of the screen
	tiles.x=math.min(0,view_width/2-player.x)
end

--check the list of tiles for a collision
--offset_x/y are how far to shift from the player's position, in pixels
--returns a table with the tile numbers that are being collided as keys along with a .empty key
-- .empty will be true if nothing was collided with, false otherwise
player.getCollisions=function(self,offset_x,offset_y)
	result={empty=true}
	if offset_x==nil then offset_x=0 end
	if offset_y==nil then offset_y=0 end
	--cycle through all tiles, get what type of tile we hit
	for ii=1,tiles.count do
		local other=tiles.map[ii]
		if squcol(self.x+offset_x,self.y+offset_y,1,other.x,other.y,other.scale) then
			--store in the list
			result[other.kind]=true
			result.empty=false
			--change the sprite
			other.tx=other.tx2
			other.ty=other.ty2
			other.spr_time=other.spr_time_max
		end
	end
	return result
end

--draw the player object
player.draw=function(self)
	spr(self.x+tiles.x,self.y+tiles.y,1,0,0)
end

--reset the game (also gets automatically called at the start of the game
function init()
	player:init()
	levels[1]()
end

--main game loop, gets called every frame
function step()
	--draw a nice sky gradient
	gradient_bg(255,255,224,32,96,204)
	--draw the sample text
	text("quig platform game example", 0,0, 1, 2)
	--update the game only if we're not paused
	--if we had a separate update step for tiles, we'd put that in here too
	if not paused then
		player:update()
	end
	--draw everything
	tiles:draw()
	player:draw()
	--draw the paused text in the bottom right corner if we are paused, putting it on top of everything else
	if paused then
		local pausetxt="[paused]"
		local pausescale=2
		--the magic number 8 here is because the quig font is an 8x8 font
		text(
			pausetxt,
			view_width-string.len(pausetxt)*8*pausescale,
			view_height-8*pausescale,pausescale, 
			0
		)
	end
	--toggle between pausing or not
	if key(key_start)==1 then paused = not paused end
end
